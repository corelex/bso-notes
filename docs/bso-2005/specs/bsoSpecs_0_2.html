<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>BSO Specs</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><link href="specs.css" rel="stylesheet" type="text/css"></head><body><h1>BSO Browser-Editor Specifications</h1><p>Version 0.2<br>Marc Verhagen, November 2005 </p><h2>1. Platform and Limitations</h2><p>BSO will be edited through a web browser to allow  easy access to editors. A couple of things will notbe possible for simplicity's sake:</p><ol>  <li>No personal playpen for each editor        and no forking of the ontology. When changes are made they are visible      to eveyone immediately. Ontology changes may require that the editor needs    to be looking at the very last version of the type that is being changed    or deleted.      The      same will be the case for lexical entries.</li>  <li>Simple password protection. The browser will not be world accessable, access    is restricted using Apache's htaccess, not using a more protected database    with passwords.</li>  <li>Some parts          of the ontology are off-limits. No editing of upper lattice types    like [[Event]] and [[Functional Entity]].</li>  <li>No rollback mechanism for          each editor. However, there is going to be a changelist that can be    consulted by anyone.</li>  <li>Editing the Ontology may be limited to a        few people only. We may even require single-user-mode for certain types    of edits.</li></ol><h2>2. Features</h2><p>Here's a list of things that the BSO browser-editor will provide. Browser  window <a href="mockups.html">mockups</a> are available to illustrate the prose  below.</p><h3>2.1. BSO Browser Main Window</h3><p> The main window displays BSO types and entries. It has at least simple search  capabilites, allowing search of entries and stems. Search with wild cards may  turn out to be useful. The main window has no editing functionality, but it  does contain buttons that fire  up the  editing  tools in  separate windows. </p><p>For a type, the following information is displayed:</p><ol>  <li>position in  the hierarchy,</li>  <li>qualia and argument roles, if any, including markers to indicate whether    qualia and roles are inherited or not: local role to type mappings are indicated    with upper case ISA and inherited mappings are indicated with lower case    isa,</li>  <li>role mappings,</li>  <li>entries that go with the type,</li>  <li>subtypes, a collapsable tree or flat list  of direct subtypes,</li>  <li>buttons to (i) add an entry to the type, (ii) add a new subtype to the    type, (iii) edit the type, (iv) delete the type, (v) move all entries to    another type, and    (vi)    refresh    the display with the    latest    version from    the server.</li></ol><p>  And for an entry, you'll see</p><ol>  <li>the entry's category and type,</li>  <li>role mappings,</li>  <li>bound arguments,</li>  <li>preposition mappings,</li>  <li>features list,</li>  <li>entries with same type,</li>  <li>information from the type blended in (roles and qualia),</li>  <li>buttons to (i) edit the entry, (ii)     delete the entry, and (iii) refresh the display with the latest version from    the server.</li></ol><p>All types and entries displayed in the main window are links, clicking the  link will load the type orentry  in the current browser window.</p><p>Unresolved issues:</p><ol>  <li>What the heck are the matching roles that appear on some                                events?</li>  <li>Integration with CPA, see section 3 below.</li>  <li>Subtype and entry display in main window when a type is displayed. The    ideal would be a collapseable tree, the poor man's version would be to simply    display lists of entries, subtypes, and sister types.</li>  <li>What to do when an entry has more than one type? This can happen when you    search for an ambiguous entry (selecting an entry that is listed with a type    should only display that particular sense). One option is to provide a dialog    where the user has to select one sense. The other option (which has my preference    and which happens to be the way Catherine has implemented it for the current    BSO browser) is to list all senses. The first sense is the one for which    the subtypes and entries are displayed; other senses should be clickable,    clicking on of them would promote it to the first position, with entries    and subtypes displayed.</li></ol><h3>2.2. AddEntry  Window</h3><p>Launched from the 'Add Entry' button in the type display of the main window.  Implemented as a form and allows you to fill in the values of all entry attributes.  The attributes and values are restrained by pulldowns wherever possible. The  type  will already  be filled in, but all other fields are blanco. When the  form  is  submitted,  the  server will check the vality of the changes and will warn if something is not  right. The following errors are possible:</p><ol>  <li>a type that the entry refers to does not exist</li>  <li>somebody else already created that entry with the same type</li></ol><p>In those cases a warning will be displayed in the AddEntry window, otherwise  the window will display a succes message. </p><p>When a new entry is successfully    submitted through the AddEntry window, it is immediately available to all  other users of the BSO browser (of course, they may need to update their display    first). Ideally, some Javascript  in the AddEntry window will instruct the user's main window  to reload and be up to date. This is the case for all Editors fired up from  the main window (that is, the AddType, EditType, DeleteType, MoveEntries, EditEntry  and DeleteEntry Windows). To avoid repetition, this behaviour  will not be reported under those headings. </p><h3>2.4. AddType Window</h3><p>Launched from the 'Add Subtype' button in the type display of the main  window. Implemented as a form and allows you to fill in the values of all type  attributes.  The attributes and values are restrained by pulldowns wherever possible. The  type will already be filled in, but all other fields are blanco (one could  argue that values inherited from supertypes should be displayed). When the  form  is  submitted,  the  server will check the vality of the changes and will warn if something is not  right. The following errors are possible:</p><ol>  <li>a type that the type refers to does not exist</li>  <li>a type with the same name already exists</li></ol><p>In those cases a warning will be displayed in the AddType window, otherwise  the window will display a succes message. The first error could happen when  somebody just renamed or deleted the type that the added type was to be a subtype  of.</p><h3>2.5. EditType Window</h3><p>Launched from the Edit Type' button in the type display of the main window.  Implemented as a form and allows you to change the values of all type attributes.The attributes and values are restrained by pulldowns wherever possible.When  the form is submitted, the server will check the vality of the changes andwill warn if something is not right. The following errors are possible:</p><ol>  <li>a type that the type refers to does not exist</li>  <li>a type with the same name already exists (this could happen if you change    the name of the type or somebody else has deleted your type and created another    one with the same name)</li></ol><p>In those cases a warning will be displayed in the EditType window, otherwise  the window will display a succes message. </p><p>After types are edited, the ontology                                                        will always be left ina consistent state. This means that changes to roles will be percolated down  the type tree to all types that are subsumed by the edited type. (implementation  note: this may not be necessary, see the remark in section 4 below). If the  name of a type is edited then the name needs to be changed everywhere the type  is referred to.</p><h3>2.6. DeleteType Window </h3><p>This window presents the repurcussions of deleting a type after pressing the  'Delete Type' button in the type display of the main window. How many subtypes  are deleted? How many entries are involved? How many types refer  to  types (though  qualia and arguments) that are being deleted? The user not only needs to confirm  but also needs to provide some more information:</p><ol>  <li>what needs to be done with entries in the part of the ontology that is    deleted: entries could either be deleted with the type or the user can specify    a new landing place in the ontology for the entries (it is probably not worth    implementing functionality that allows you to delete someentries but keep    others)</li>  <li>what needs to be done with types that refer to deleted types: have them    refer to [[TopType]] or to the type that is the landing place for orphaned    entries.</li></ol><p>On submit, the server will check for potential errors:</p><ol>  <li>some types in the upper-lattice cannot be deleted</li>  <li>some types may already have been deleted (this is not really an error but    a warning)</li>  <li>some types may have moved to another part of the ontology</li></ol><p>Appropriate error messages will be displayed in the DeleteType window.</p><h3>2.7. MoveEntries Window</h3><p>Launched from the Move Entries' button in the type display of the main  window. Implemented as a form that asks for confirmation and the name of the  new type. When  the form is submitted, the server will check whether the new type exists andwhether lexical information on the entries is compatible with the new type (does  the entry refer to a role that does not exist on the type?). If entries are  not compatible with the type then the user has the option to remove incompatible  information.</p><h3>2.8. EditEntry Window</h3><p>Launched from the Edit Entry' button in the entry display of the main  window. Implemented as a form and allows you to fill in the values of all entry  attributes.  The attributes and values are restrained by pulldowns wherever possible. .  When the form is submitted, the server will check the vality of the changes  and willwarn if something is not right. The follwoing errors are possible:</p><ol>  <li>the entry refers to a type that does not exist</li>  <li>the entry is not compatible with its type</li></ol><p>Errors are printed to the window.</p><h3>2.9. DeleteEntry Window</h3><p>Simply asking for confirmation and checking whether the entry was still there.</p><h3>2.10. TypeOrEntryChanged</h3><p>A warning window that pops up when                                                      a user selects a linked      type or                                                      entry                                                      that does not exist anymore.</p><h3>2.11. ChangeList</h3><p>Displays all changes made sofar, could be as simple as one long list of changes,    but should probably allow the user to set certain parameters like timeframe,    person who made the change, entry or type that was changed etcetera. This  could be launched from a menu on the main window or be totally separate from  the browser.</p><p>The change list is not editable, it is just there to inform the editor. Onepre-requisite is to define a language to represent changes.</p><h3>2.12. Batch Processing</h3><p>There is going to be some mechanism to allow batch processing. Large amounts  of deletions and changes can potentially be defined automatically. For those  changes, we need a simple specification language, potentially designed  on the fly when  automated editing options pop up.</p><p>This functionality may not be provided in the browser but rather run locally  on eurydice.</p><h2>3. BSO Browser and CPA</h2><p>Discussions are still raging about how to develop BSO and CPA at the same  time, a matter made a tad complicated because these two resources depend on  eachother. The CPA editor is going to provide access to the type(s) of a lexical  entry and all its supertypes. In addition, it can fire up the BSO browser for  a particular type and inspect what entries go with it. There are three pieces  of information from CPA development that are useful for BSO:</p><ol>  <li>a particular BSO type is used in a CPA pattern</li>  <li>a BSO entry E is considered to be a good exemplar of type T</li>  <li>a BSO entry E is considered to be a bad exemplar of type T</li></ol><p class="emphasis">In addition, <span class="emphasis">we may want to leave    information about what pattern linked to a type or entry.</span> Sometimes    a pattern refers to a subset of the lexical set of a tpye and the lexical    set is considered to be a good one. Then the pattern could refer to type    T and its subset {ei...ej}. We would the BSO entry to know about this.</p><p>We're hashing out how this information gets to BSO, it could involve    limited BSO editing permissions for CPA editors (all they would be able to    do is add    flags to types and entries). We may make it hard for BSO editors to remove    types that are used by CPA. If those types are renamed than CPA needs to  be informed. Similarly, good entries for a particular type should not be moved    at a whim.</p><p>We also need to decide if some CPA information (lexical sets for example,  or the CPA patterns themselves) should be added to BSO.</p></body></html>