<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Untitled Document</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><link href="design.css" rel="stylesheet" type="text/css"></head><body><h1>BSO Editor Design Notes</h1>Version 0.2, December 2005<br/>Marc Verhagen, with input from Catherine Havasi and Anna Rumshisky<h2>1. Consistency Checking</h2><p>There are three kinds of consistency checking:</p><ol>  <li>referential integrity of individual types and entries: no type or entry    may refer to non-existing types,</li>  <li>consistency of type hierarchy: enforce correct inheritance of roles, this    is an artifact of having inherited roles stored on the types in the database</li>  <li>consistency of an entry argument mapping with its type: an entry may not    refer in its rolemapping to a role that does not exist on the type (this    means    that    an    entry can become    inconsistent with its type when the type's roles are changed).</li></ol><p>The old BSO   did not enforce entry-type consistency.  This means that the current ontology could be full of inconsistencies. We need  to decide whether we want to enforce consitency type 3. If we do, we need to  decide what it actually means. Is an entry never allowed to refer to a type  that does not occur on the tpye? Is an entry allowed to not express roles on  the type? My first hunch would be to say 'yes' and 'yes'.</p><p>Each time a type or entry is changed, we need to ensure referential  integrity (type 1 above, as well as the special version in 3, if we  choose to enforce it), making sure that new or changed local  attributes are valid. But some changes, that is, changes to types,  have non-local effects and may introduce inconsistency of other  objects, inconsistency of the type system or inconsistencies between  types and entries. A change to a type can have repercussions of four  kinds of objects in the ontology:</p><ol>   <li>subtypes of T (types that occur in the tree underneath T)</li>  <li>entries of T and of subtypes of T</li>  <li>types that refer to T in their qualia structure, argument roles or matching    roles</li>  <li>entries that refer to T in their bound arguments or preposition mappings</li></ol><p>The table below lays out  what needs to be done when a type T is changed.  The columns indicate the kinds of changes that can be made to a type and therows indicate the four objects listed above.</p><table border="1" cellpadding="5" cellspacing="0" bordercolor="#666666">  <tr>    <th>&nbsp;</th>    <th width="215" align="left">rename to T'</th>    <th width="120" align="left">remove</th>    <th width="134" align="left">change&nbsp;supertype</th>    <th width="130" align="left">change&nbsp;attributes</th>  </tr>  <tr valign="top">    <td>subtypes</td>    <td>direct subtypes change name of supertype to T'</td>    <td>remove</td>    <td>change inherited attributes</td>    <td>change inherited attributes</td>  </tr>  <tr valign="top">    <td>entries&nbsp;in&nbsp;subtree</td>    <td>no change</td>    <td>remove or move to user-specified type</td>    <td>check consistency with new inherited attributes on the type</td>    <td>check consistency with new local or inherited attributes of the type</td>  </tr>  <tr valign="top">    <td>referring&nbsp;types<br>    referring&nbsp;entries</td>    <td>change value of referring attributes from T to T'</td>    <td>change value of referring attribute to user-specified type</td>    <td>no change</td>    <td>no change</td>  </tr></table><p>The core Python database wrapper needs to implement most of the  functionality needed to make the above work. Amongs others, it needs to implement  methods to retrieve (i) entries and types that refer to a partical type, (ii)  sub types of a type, (iii) entries that belong to a type, etcetc.</p><h3>1.1. Consistency and Multiple Editors</h3><p>There are a couple of choices:</p><ol>  <li>Introduce a single-editor mode, where some editor, more equal      than others, gets to change the type system while no one else is      allowed to make changes. This is the simplest way and has my      preference. It could be implemented by allowing some people to      grab a lock, make a bunch of edits and then release the      lock. While the lock is in place, other users would see some      kind of read-only icon in the browser, and the AddEnry buttons      etc won't work. The disadvantage is the inconvenience to the      editors. At least all entry editing should remain totally      multi-user. </li>  <li>Like 1, but the lock is grabbed at a lower level using something like an    Oracle transaction for those changes that require other changes to other    table rows. However, MySQL has no concept of transactions for its deafult    MyISAM tables (it does have something called innoDB tables, with transactions,    but these require special setup). Without transactions, you'll have to somehow    grab the lower level locks for all rows that need work, this may become too    complicated and may not preserve integrity anyway.</li>  <li>A pure multi-user mode for all occasions. We need to be much more careful    for all those cases where two editors change things that are interdependent.    This was a total pain for the old smalltalk interface, but would actually    be less involved with our indivdual tpye/entry based personal playpen devoid    BSO browser. Still, I'm hesitant.</li>  <li>An approach where all changes made by an editor are not immediately made    visible in the database but rather stored in some kind of change log which    can be ran as a batch job in single-editor mode later on. We'll never have    to worry about locks, but it is  sub-optimal that edits to the lexicon cannot    be viewed immediately.</li></ol><p>The first one is the current choice of record.</p><h2>2. Database Structure</h2><p>Now is the time to make  changes to the overal layout of the database. It   is unlikely to happen later on, when we are actually editing the ontology.  Here's my suggestion.</p><p><strong>BSO_TYPE</strong></p><blockquote><table border="1" cellspacing="0" cellpadding="3">  <tr>    <td>typeID</td>    <td>VARCHAR, KEY</td>    <td>a unique ID for the type, for example t891</td>  </tr>  <tr>    <td>typeName</td>    <td>VARCHAR</td>    <td>a unique name for the type</td>  </tr>  <tr>    <td>onType</td>    <td>VARCHAR</td>    <td>the ID of the supertype</td>  </tr>  <tr>    <td>andType</td>    <td>NULL or VARCHAR</td>    <td>the ID of a 2nd supertype (for complex types)</td>  </tr>  <tr>    <td>editor</td>    <td>VARCHAR</td>    <td>the editor who   last touched this type</td>  </tr>  <tr>    <td>timestamp</td>    <td>TIMESTAMP</td>    <td>time of last edit</td>  </tr></table><p>Using IDs is not strictly necessary since the type name is unique. but it  does make changing type names easier.</p><p>The cpa field is there so that CPA editors can leave flags. Those flags might  be set by BSO people rather than CPA people though.</p><p>The editor field refers to the person who last made a change to some part  of the type, possibly to another table like BSO_TYPE_QUALIA. Similarly, the  timestamp refers to the last edit made to the type as a wole, not necessary  to a value in this table.</p></blockquote><p><strong>BSO_TYPE_QUALIA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>a unique ID for the type</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>      <td>name of qualia role</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>value of role, the ID of a type</td>    </tr>    <tr>      <td>inherited</td>      <td>BOOL</td>      <td>is role inherited?</td>    </tr>  </table>  <p>PrimaryKey = (typeID,name)</p>  <p>All qualia go here and  the distiction      between the two kinds of qualia gets ditched.</p>  <p>A note on foreign keys. Allegedly, MySQL does have a limited implementation    of foreign keys using the REFERENCES keyword. For the above table, the typeID    row would have &quot;REFERENCES BSO_TYPE(typeID)&quot; as part of its definition in    the table schema. This is supposed to enforce referential constraints, but    does not trigger cacading deletes. However, when I tried this on the mysql    version on my computer (4.014) it did seem to take. So we may not be able    to use this mechanism for consistency checking.</p>  <p>Currently, the roles and qualia are compiled out throughout the    tree. That is, if a type X has qualia Q with value V, then a    subtype Y of X will also have qualia Q with value V, and these    values are stored in the table with Y. We may consider changing    this. It would reduce the size of the databse and obviate the need    to create consistency after some type edits. On the other hand,    each time a type is displayed all its supertypes would need to be    consulted, increasing the number of selects. But note that this is    necessary anyway because the BSO browser needs to display the path    to the top of the hierarchy.  In any case, the inherited field is    not needed if only local roles end up in this table.</p></blockquote><p><strong>BSO_TYPE_ARGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>a unique ID for the type</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>      <td>name of argument role</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>value of role, the ID of a type</td>    </tr>    <tr>      <td>inherited</td>      <td>BOOL</td>      <td>is role inherited?</td>    </tr>  </table>  <p>PrimaryKey = (typeID,name)</p>  <p>Similar to qualia table. Same comment on the inherited field is relevant    here.</p></blockquote><p><strong>BSO_TYPE_MATCHINGROLES</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>role1</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>role2</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>type</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table>  <p>The ENUMERATION datatype is there to enforce limited choice of roles. However,    this should probably not be implemented by a constraint on a table filed,    but rather in a separate table that lists the values allowed, something like</p>  <blockquote>    <table border="1" cellspacing="0" cellpadding="3">      <tr>        <td>tableName</td>        <td>VARCHAR</td>      </tr>      <tr>        <td>tableField</td>        <td>VARCHAR</td>      </tr>      <tr>        <td>allowewdValue</td>        <td>VARCHAR</td>      </tr>    </table>    </blockquote>  <p>It now looks like BSO_TYPE_MATCHINGROLES  may not be needed at all since    the matching roles seem irrelevant to us.</p></blockquote><p><strong>BSO_TYPE_CPA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, KEY, FOREIGN KEY</td>    </tr>    <tr>      <td>cpa</td>      <td>BOOL</td>    </tr>  </table>  <p>This table may need to be more complex. The above version allows you to    say that a type is refered to by a CPA pattern.</p></blockquote><p><strong>BSO_TYPE_COMMENT</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, KEY, FOREIGN KEY</td>    </tr>    <tr>      <td>editor</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>    <tr>      <td>comment</td>      <td>TEXT</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR,  KEY</td>      <td>a unique ID for the entry, for example e1788</td>    </tr>    <tr>      <td>word</td>      <td>VARCHAR</td>      <td>name of the entry</td>    </tr>    <tr>      <td>stem</td>      <td>VARCHAR</td>      <td>stem of the entry</td>    </tr>    <tr>      <td>type</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>type of the entry, the ID of a type</td>    </tr>    <tr>      <td>tag</td>      <td>VARCHAR</td>      <td>syntactic category</td>    </tr>    <tr>      <td>editor</td>      <td>VARCHAR</td>      <td>the editor who last touched this entry</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>      <td>time of last edit</td>    </tr>  </table>  <p>Perhaps we should have a separate table for CPA flags. So we would be able    to collect multiple flags for an entry in case they change over time.</p></blockquote><p><strong>BSO_ENTRY_PREPMAPS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>type1</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>role</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>type2</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table>  <p>type1 and type2 should be renamed in slightly more descriptive names, but    I forgot what those two actually do and we're not touching prepositions yet</p></blockquote><p><strong>BSO_ENTRY_BOUNDARGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>localRole</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>remoteRole</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>remoteType</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY_FEATURES</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY_CPA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>cpaStatus</td>      <td>BOOL</td>    </tr>  </table>  <p>PrimaryKey = (entryID, typeID)</p>  <p>This table may need to be more complex. The above version allows you to    say that an entry is considered to be a good or bad example of a type.</p></blockquote><p><strong>BSO_ENTRY_COMMENTS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>editor</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>    <tr>      <td>comment</td>      <td>TEXT</td>    </tr>  </table></blockquote><p><strong>BSO_REFERENCE_INDEX</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td width="52">referred</td>      <td width="183">VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>referent</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>type</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>  </table>  <p>ENUMERATION = (type, subtype, qualia, argument, boundarg, prepositionmapping,    matchingrole).</p>  <p>The enumeration in this table, unlike all others, is a true enumeration    that should be implemented as a MySQL limitation on field values.</p>  <p>This table is there to give quick acces to all types and entries that    refer to a type. It contains all subtypes, all entires belong to the type    etc. One problem with using a table like this is that it needs to be maintained.    Each time a type or entry is edited, rows in this table may need to be removed    and/or added. An alternative is to not use this table and use indexes on    the relevant fields in other tables instead. This is now my preferred approach.</p>  </blockquote><p><strong>BSO_CHANGELIST</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>id</td>      <td>AUTONUMBER</td>    </tr>    <tr>      <td width="52">date</td>      <td width="183">TIMESTAMP</td>    </tr>    <tr>      <td>editor</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>type</td>      <td>NULL or VARCHAR</td>    </tr>    <tr>      <td>entry</td>      <td>NULL or VARCHAR</td>    </tr>    <tr>      <td>derived</td>      <td>BOOL</td>    </tr>    <tr>      <td>description</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>  </table>  <p>A list with all changes made to the ontology and lexicon. The smalltalk    version implemented this by adding a revision number to each entry and type.    Changes would not overwrite an existing table row but simply add one.</p>  <p>This list is not intended to be used for recovery or backup, some other    logging mechansim can be used for that. It is simply there for editors to    refer to. The table makes a distinction between changes that are primary    and those that are derived (derived changes are those made because another    change was made, eg changing the type of an entry because its type was deleted).</p></blockquote><p>&nbsp;</p></body></html>