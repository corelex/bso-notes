<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>BSO Browser Design</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><link href="design.css" rel="stylesheet" type="text/css"></head><body><h1>BSO Editor Design Notes</h1>Version 0.3, December 9th, 2005<br/>Marc Verhagen, with input from Catherine Havasi and Anna Rumshisky<h2>1. Consistency Checking</h2><p>There are three kinds of consistency checking:</p><ol>  <li>referential integrity of individual types and entries: no type or entry    may refer to non-existing types,</li>  <li>consistency of type hierarchy: enforce correct inheritance of    roles, this is an artifact of having inherited roles stored on the    types in the database</li>  <li>consistency of an entry argument mapping with its type: an entry    may not refer in its rolemapping to a role that does not exist on    the type (this means that an entry can become inconsistent with    its type when the type's roles are changed).</li></ol><p class="emphasis">Add decisions about type-entry consistency, aswell as the blurbs on entries setting restrictions on the types ofroles.</p><p>The old BSO did not enforce entry-type consistency.  This means  that the current ontology could be full of inconsistencies. We need  to decide whether we want to enforce consitency type 3. If we do, we  need to decide what it actually means. Is an entry never allowed to  refer to a type that does not occur on the tpye? Is an entry allowed  to not express roles on the type? My first hunch would be to say  'yes' and 'yes'.</p><p>Each time a type or entry is changed, we need to ensure referential  integrity (type 1 above, as well as the special version in 3, if we  choose to enforce it), making sure that new or changed local  attributes are valid. But some changes, that is, changes to types,  have non-local effects and may introduce inconsistency of other  objects, inconsistency of the type system or inconsistencies between  types and entries. A change to a type can have repercussions of four  kinds of objects in the ontology:</p><ol>   <li>subtypes of T (types that occur in the tree underneath T)</li>  <li>entries of T and of subtypes of T</li>  <li>types that refer to T in their qualia structure, argument roles    or matching roles</li>  <li>entries that refer to T in their bound arguments or preposition mappings</li></ol><p class="emphasis">Also add how bound arguments introduce adependency on a type not mentioned in the entry. Say we have#telic:#externalArgument = [[Novel]], the type that is the value ofthe telic cannot remove its external argument. Anna claims there issome kind of other hidden dependency between two types, this will beignored untill she comes up with an example.</p><p>The table below lays out  what needs to be done when a type T is changed.  The columns indicate the kinds of changes that can be made to a type and therows indicate the four objects listed above.</p><table border="1" cellpadding="5" cellspacing="0" bordercolor="#666666">  <tr>    <th>&nbsp;</th>    <th width="215" align="left">rename to T'</th>    <th width="120" align="left">remove</th>    <th width="134" align="left">change&nbsp;supertype</th>    <th width="130" align="left">change&nbsp;attributes</th>  </tr>  <tr valign="top">    <td>subtypes</td>    <td>direct subtypes change name of supertype to T'</td>    <td>remove</td>    <td>change inherited attributes</td>    <td>change inherited attributes</td>  </tr>  <tr valign="top">    <td>entries&nbsp;in&nbsp;subtree</td>    <td>no change</td>    <td>remove or move to user-specified type</td>    <td>check consistency with new inherited attributes on the type</td>    <td>check consistency with new local or inherited attributes of the type</td>  </tr>  <tr valign="top">    <td>referring&nbsp;types<br>    referring&nbsp;entries</td>    <td>change value of referring attributes from T to T'</td>    <td>change value of referring attribute to user-specified type</td>    <td>no change</td>    <td>no change</td>  </tr></table><p class="emphasis">Need to add the hidden dependency from boundarguments to the table.</p><p>The core Python database wrapper needs to implement most of the  functionality needed to make the above work. Amongs others, it needs to implement  methods to retrieve (i) entries and types that refer to a partical type, (ii)  sub types of a type, (iii) entries that belong to a type, etcetc.</p><h3>1.1. Consistency and Multiple Editors</h3><p>There are a couple of choices:</p><ol>  <li>Introduce a single-editor mode, where some editor, more equal      than others, gets to change the type system while no one else is      allowed to make changes. This is the simplest way and has my      preference. It could be implemented by allowing some people to      grab a lock file, make a bunch of edits and then release the      lock. While the lock is in place, other users would see some      kind of read-only icon in the browser, and the AddEnry buttons      etc won't work. The disadvantage is the inconvenience to the      editors. At least all entry editing should remain totally      multi-user. </li>  <li>Like 1, but the lock is grabbed at a lower level using something      like an Oracle transaction for those changes that require other      changes to other table rows. However, MySQL has no concept of      transactions for its deafult MyISAM tables (it does have      something called innoDB tables, with transactions, but these      require special setup). Without transactions, you'll have to      somehow grab the lower level locks for all rows that need work,      this may become too complicated and may not preserve integrity      anyway.</li>  <li>A pure multi-user mode for all occasions. We need to be much      more careful for all those cases where two editors change things      that are interdependent.  This was a total pain for the old      smalltalk interface, but would actually be less involved with      our indivdual tpye/entry based personal playpen devoid BSO      browser. Still, I'm hesitant.</li>  <li>An approach where all changes made by an editor are not      immediately made visible in the database but rather stored in      some kind of change log which can be ran as a batch job in      single-editor mode later on. We'll never have to worry about      locks, but it is sub-optimal that edits to the lexicon cannot be      viewed immediately.</li></ol><p>The first one is the current choice of record.</p><h2>2. Database Structure</h2><p>Now is the time to make  changes to the overal layout of the database. It   is unlikely to happen later on, when we are actually editing the ontology.  Here's my suggestion.</p><p><strong>BSO_TYPE</strong></p><blockquote><table border="1" cellspacing="0" cellpadding="3">  <tr>    <td>typeID</td>    <td>VARCHAR, KEY</td>    <td>a unique ID for the type, for example t891</td>  </tr>  <tr>    <td>typeName</td>    <td>VARCHAR</td>    <td>a unique name for the type</td>  </tr>  <tr>    <td>onType</td>    <td>VARCHAR</td>    <td>the ID of the supertype</td>  </tr>  <tr>    <td>andType</td>    <td>NULL or VARCHAR</td>    <td>the ID of a 2nd supertype (for complex types)</td>  </tr>  <tr>    <td>editor</td>    <td>VARCHAR</td>    <td>the editor who   last touched this type</td>  </tr>  <tr>    <td>timestamp</td>    <td>TIMESTAMP</td>    <td>time of last edit</td>  </tr></table><p>Using IDs is not strictly necessary since the type name is unique. but it  does make changing type names easier.</p><p>The editor field refers to the person who last made a change to some part  of the type, possibly to another table like BSO_TYPE_QUALIA. Similarly, the  timestamp refers to the last edit made to the type as a whole, not necessary  to a value in this table.</p></blockquote><p><strong>BSO_TYPE_QUALIA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>a unique ID for the type</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>      <td>name of qualia role</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>value of role, the ID of a type</td>    </tr>    <tr>      <td>inherited</td>      <td>BOOL</td>      <td>is role inherited?</td>    </tr>  </table>  <p>PrimaryKey = (typeID,name)</p>  <p>The old BSO had a distinction between qualia directly expressed     as an attribute of the type and qualia that were stored in a     separate data structure. This distiction is eliminated.</p>  <p>A note on foreign keys. Allegedly, MySQL does have a limited     implementation of foreign keys using the REFERENCES keyword. For     the above table, the typeID row would have &quot;REFERENCES     BSO_TYPE(typeID)&quot; as part of its definition in the table     schema. This is supposed to enforce referential constraints, but     does not trigger cascading deletes. However, when I tried this on     the mysql version on my computer (4.014) it did not seem to     take. So we may not be able to use this mechanism for consistency     checking.</p>  <p>Currently, the roles and qualia are compiled out throughout the     tree. That is, if a type X has qualia Q with value V, then a     subtype Y of X will also have qualia Q with value V, and these     values are stored in the table with Y. We may consider changing     this. It would reduce the size of the database and obviate the     need to create consistency after some type edits. On the other     hand, each time a type is displayed all its supertypes would need     to be consulted, increasing the number of selects. But note that     this is necessary anyway because the BSO browser needs to display     the path to the top of the hierarchy.  In any case, the inherited     field is not needed if only local roles end up in this table.</p></blockquote><p><strong>BSO_TYPE_ARGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>a unique ID for the type</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>      <td>name of argument role</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>value of role, the ID of a type</td>    </tr>    <tr>      <td>inherited</td>      <td>BOOL</td>      <td>is role inherited?</td>    </tr>  </table>  <p>PrimaryKey = (typeID,name)</p>  <p>Similar to qualia table. Same comment on the inherited field is relevant    here.</p></blockquote><p><strong>BSO_TYPE_CPA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, KEY, FOREIGN KEY</td>    </tr>    <tr>      <td>cpa</td>      <td>BOOL</td>    </tr>  </table>  <p>This table may need to be more complex. The above version allows you to    say that a type is refered to by a CPA pattern.</p></blockquote><p><strong>BSO_TYPE_COMMENT</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, KEY, FOREIGN KEY</td>    </tr>    <tr>      <td>editor</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>    <tr>      <td>comment</td>      <td>TEXT</td>    </tr>  </table>  <p>The ENUMERATION datatype is there to enforce limited choice of     values. However, this should probably not be implemented by a     constraint on a table filed, but rather in a separate table that     lists the values allowed, something like</p>  <blockquote>    <table border="1" cellspacing="0" cellpadding="3">      <tr>        <td>tableName</td>        <td>VARCHAR</td>      </tr>      <tr>        <td>tableField</td>        <td>VARCHAR</td>      </tr>      <tr>        <td>allowedValue</td>        <td>VARCHAR</td>      </tr>    </table>    </blockquote></blockquote><p><strong>BSO_ENTRY</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR,  KEY</td>      <td>a unique ID for the entry, for example e1788</td>    </tr>    <tr>      <td>word</td>      <td>VARCHAR</td>      <td>name of the entry</td>    </tr>    <tr>      <td>stem</td>      <td>VARCHAR</td>      <td>stem of the entry</td>    </tr>    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>the ID of the type of the entry</td>    </tr>    <tr>      <td>tag</td>      <td>VARCHAR</td>      <td>syntactic category</td>    </tr>    <tr>      <td>editor</td>      <td>VARCHAR</td>      <td>the editor who last touched this entry</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>      <td>time of last edit</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY_ROLEMAPPINGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>frame</td>      <td>INTEGER</td>    </tr>    <tr>      <td>syn_role</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>sem_role</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>type</td>      <td>NULL or FOREIGN KEY</td>    </tr>  </table>  <p>The sem_role could be an argument role or a qualia role,     depending on whether the entry is an entity or an event. We could     consider to split this table in two, BSO_ENTRY_ARGMAPPINGS and     BSO_ENTRY_QUALIAMAPPINGS, on a par with the BSO_TYPE_QUALIA and     BSO_TYPE_ARGS tables.</p>  <p>This table can deal with two kinds of disjunctions: disjunctions     of role values and disjunctions of subcategorisation     frames. Here's an example of an entry with two role value     disjunctions:</p>	 <blockquote>	 entry(e17,rolemapping):<br/>	 &nbsp;&nbsp;#objectRole = (#theme or #goal)<br/>	 &nbsp;&nbsp;#subjectRole = (#externalArgument:[[Combustable]] or externalArgument:[[Beverage]])	 </blockquote>  <p>And here's one of a disjunction on a whole frame:</p>	 <blockquote>	 entry(e18,rolemapping):<br/>	 &nbsp;&nbsp;(#subjectRole = #externalArgument:[[Beverage]]<br/>	 &nbsp;&nbsp; #objectRole = #theme)<br/>	 &nbsp;&nbsp; or<br/>	 &nbsp;&nbsp;(#subjectRole = #theme<br/>	 &nbsp;&nbsp; #objectRole = #externalArgument:[[Beverage]])	 </blockquote>  <p>We'll accept redundancy when dealing with the first kind and we     use the frame field to deal with disjungtive subcategorisation     frames. Taking the two examples above, the fragment in the tables     to describe them is as follows (the type is printed with its     name, rather than an ID, this is not right of course, but it     explains better):</p>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>frameNo</td>      <td>syn_role</td>      <td>sem_role</td>      <td>type</td>    </tr>    <tr>      <td>e17</td>      <td>1</td>      <td>#objectRole</td>      <td>#theme</td>      <td>NULL</td>    </tr>    <tr>      <td>e17</td>      <td>1</td>      <td>#objectRole</td>      <td>#goal</td>      <td>NULL</td>    </tr>    <tr>      <td>e17</td>      <td>1</td>      <td>#subjectRole</td>      <td>#externalArgument</td>      <td>Combustable</td>    </tr>    <tr>      <td>e17</td>      <td>1</td>      <td>#subjectRole</td>      <td>#externalArgument</td>      <td>Beverage</td>    </tr>    <tr>      <td>e18</td>      <td>1</td>      <td>#subjectRole</td>      <td>#externalArgument</td>      <td>Beverage</td>    </tr>    <tr>      <td>e18</td>      <td>1</td>      <td>#objectRole</td>      <td>#theme</td>      <td>NULL</td>    </tr>    <tr>      <td>e18</td>      <td>2</td>      <td>#subjectRole</td>      <td>#theme</td>      <td>NULL</td>    </tr>    <tr>      <td>e18</td>      <td>2</td>      <td>#objectRole</td>      <td>#externalArgument</td>      <td>Beverage</td>    </tr>  </table>  <p>This table has some redundancies, but the alternative would be to     create three tables, which would be rather unintuitive.</p></blockquote><p><strong>BSO_ENTRY_PREPMAPS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>type1</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>role</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>type2</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table>  <p>type1 and type2 should be renamed in slightly more descriptive    names, but I forgot what those two actually do and we're not    touching prepositions yet.</p></blockquote><p><strong>BSO_ENTRY_BOUNDARGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>localRole</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>remoteRole</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>remoteType</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY_FEATURES</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY_CPA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>cpaStatus</td>      <td>BOOL</td>    </tr>  </table>  <p>PrimaryKey = (entryID, typeID)</p>  <p>This table may need to be more complex. The above version allows you to    say that an entry is considered to be a good or bad example of a type.</p></blockquote><p><strong>BSO_ENTRY_COMMENTS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>editor</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>    <tr>      <td>comment</td>      <td>TEXT</td>    </tr>  </table></blockquote><p><strong>BSO_REFERENCE_INDEX</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td width="52">referred</td>      <td width="183">VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>referent</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>type</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>  </table>  <p>ENUMERATION = (type, subtype, qualia, argument, boundarg,     prepositionmapping, matchingrole).</p>  <p>The enumeration in this table, unlike all others, is a true     enumeration that should be implemented as a MySQL limitation on     field values.</p>  <p>This table is there to give quick acces to all types and entries     that refer to a type. It contains all subtypes, all entires     belong to the type etc. One problem with using a table like this     is that it needs to be maintained.  Each time a type or entry is     edited, rows in this table may need to be removed and/or     added. An alternative is to not use this table and use indexes on     the relevant fields in other tables instead, using selects like     "SELECT entryID FROM BSO_ENTRY WHERE typeID='t12'" to get all     entries that have type t12 as their type. My preference is to     ditch the table.</p> </blockquote><p><strong>BSO_CHANGELIST</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>id</td>      <td>AUTONUMBER</td>    </tr>    <tr>      <td width="52">date</td>      <td width="183">TIMESTAMP</td>    </tr>    <tr>      <td>editor</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>type</td>      <td>NULL or VARCHAR</td>    </tr>    <tr>      <td>entry</td>      <td>NULL or VARCHAR</td>    </tr>    <tr>      <td>derived</td>      <td>BOOL</td>    </tr>    <tr>      <td>description</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>    </tr>  </table>  <p>A list with all changes made to the ontology and lexicon. The    smalltalk version implemented this by adding a revision number to    each entry and type.  Changes would not overwrite an existing    table row but simply add one.</p>  <p>This list is not intended to be used for recovery or backup, some    other logging mechansim can be used for that. It is simply there    for editors to refer to. The table makes a distinction between    changes that are primary and those that are derived (derived    changes are those made because another change was made, eg    changing the type of an entry because its type was deleted).</p></blockquote><p>&nbsp;</p></body></html>