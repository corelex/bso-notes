<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Untitled Document</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><link href="design.css" rel="stylesheet" type="text/css"></head><body><h1>BSO Editor Design Notes</h1>Version 0.1<br/>Marc Verhagen, December 2005<h2>1. Consistency Checking</h2><p>There are three kinds of consistency checking:</p><ol>  <li>consistency of individual types and entries: no type or entry may refer    to non-existing types,</li>  <li>consistency of type hierarchy: enforce correct inheritance of roles,</li>  <li>consistency of an entry with its type: an entry may not refer in its rolemapping    to a role that does not exist on the type (this means that an entry can become    inconsistent with its type when the type's roles are changed).</li></ol><p>The old BSO  enforced the first two, but it did not enforce entry-type consistency.  This means that the current ontology could be full of inconsistencies. We need  to decide whether we want to enforce consitency type 3. If we do, we need to  decide what it actually means. Is an entry never allowed to refer to a type  that does not occur on the tpye? Is an entry allowed to not express roles on  the type? My first hunch would be to say 'yes' and 'yes'.</p><p>Each time a type or entry is changed, we need to ensure local consistence  (type 1 above), making sure that new or changed local attributes are valid.  But some changes, that is, changes to types, have non-local effects and may  introduce inconsistency of other objects, inconsistency of the type system  or inconsistencies between types and entries. A change to a type can have repercussions  of fourkinds of objects in the ontology:</p><ol>   <li>subtypes of T (types that occur in the tree underneath T)</li>  <li>entries of T and of subtypes of T</li>  <li>types that refer to T in their qualia structure, argument roles or matching    roles</li>  <li>entries that refer to T in their bound arguments or preposition mappings</li></ol><p>The table below lays out  what needs to be done when a type T is changed.  The columns indicate the kinds of changes that can be made to a type and therows indicate the four objects listed above.</p><table border="1" cellpadding="5" cellspacing="0" bordercolor="#666666">  <tr>    <th>&nbsp;</th>    <th width="215" align="left">rename to T'</th>    <th width="120" align="left">remove</th>    <th width="134" align="left">change&nbsp;supertype</th>    <th width="130" align="left">change&nbsp;attributes</th>  </tr>  <tr valign="top">    <td>subtypes</td>    <td>direct subtypes of T change name of supertype to T'</td>    <td>remove</td>    <td>change inherited attributes</td>    <td>change inherited attributes</td>  </tr>  <tr valign="top">    <td>entries&nbsp;in&nbsp;subtree</td>    <td>no change</td>    <td>remove or move to user-specified type</td>    <td>check consistency with new inherited attributes on the type</td>    <td>check consistency with new local or inherited attributes of the type</td>  </tr>  <tr valign="top">    <td>referring&nbsp;types</td>    <td>change value of referring attribute from T to T'</td>    <td>change value of referring attribute to user-specified type</td>    <td>no change</td>    <td>no change</td>  </tr>  <tr valign="top">    <td>referring&nbsp;entries</td>    <td>change value of referring attribute  from T to T'</td>    <td>change value of referring attribute to user-specified type</td>    <td>no change</td>    <td>no change</td>  </tr></table><p>I think that the core Python database wrapper needs to implement most of the  functionality needed to make the above work.</p><h3>1.1. Consistency and Multiple Editors</h3><p>As I see it, we have two choices:</p><ol>  <li>Introduce a single-editor mode, where some editor, more      equal      than      others,      gets to change      the type system while no one else is allowed to make changes. This is the    simplest way and has my preference. It could be implemented by allowing some    people to grab a lock, make a bunch of edits and then release the lock. While    the lock is in place, other users would see some kind of read-only icon in    the browser, and the AddEnry buttons etc won't work. The disadvantage is    the inconvenience to the editors. At least all entry editing should remain    totally multi-user. </li>  <li>A pure multi-user mode for all occasions. We need to be much more careful    for all those cases where two editors change things that are interdependent.    This was a total pain for the old smalltalk interface, but would actually    be less involved with our indivdual tpye/entry based personal playpen devoid    BSO browser. Still, I'm hesitant.</li></ol><h2>2. Database Structure</h2><p>Now is the time to make  changes to the overal layout of the database. It   is unlikely to happen later on, when we are actually editing the ontology.  Here's my suggestion.</p><p><strong>BSO_TYPE</strong></p><blockquote><table border="1" cellspacing="0" cellpadding="3">  <tr>    <td>typeID</td>    <td>VARCHAR, KEY</td>    <td>a unique ID for the type, for example t891</td>  </tr>  <tr>    <td>typeName</td>    <td>VARCHAR</td>    <td>a unique name for the type</td>  </tr>  <tr>    <td>onType</td>    <td>VARCHAR</td>    <td>the ID of the supertype</td>  </tr>  <tr>    <td>andType</td>    <td>NULL or VARCHAR</td>    <td>the ID of a 2nd supertype (for complex types)</td>  </tr>  <tr>    <td>cpa</td>    <td>BOOL</td>    <td>is the type used in CPA?</td>  </tr>  <tr>    <td>comment</td>    <td>VARCHAR</td>    <td>blahblah</td>  </tr>  <tr>    <td>editor</td>    <td>VARCHAR</td>    <td>the editor who   last touched this type</td>  </tr>  <tr>    <td>timestamp</td>    <td>TIMESTAMP</td>    <td>time of last edit</td>  </tr></table><p>Using IDs is not strictly necessary since the type name is unique. but it  does make changing type names easier.</p><p>The cpa field is there so that CPA editors can leave flags. Those flags might  be set by BSO people rather than CPA people though.</p><p>The editor field refers to the person who last made a change to some part  of the type, possibly to another table like BSO_TYPE_QUALIA. Similarly, the  timestamp refers to the last edit made to the type as a wole, not necessary  to a value in this table.</p></blockquote><p><strong>BSO_TYPE_QUALIA</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>a unique ID for the type</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>      <td>name of qualia role</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>value of role, the ID of a type</td>    </tr>    <tr>      <td>inherited</td>      <td>BOOL</td>      <td>is role inherited?</td>    </tr>  </table>  <p>PrimaryKey = (typeID,name)</p>  <p>All qualia go here and  the distiction      between the two kinds of qualia gets ditched.</p>  <p>Currently, the roles and qualia are compiled out throughout the tree. That    is, if a type X has qualia Q with value V, then a subtype Y of X will also    have qualia Q with value V, and these values are stored in the table with    Y. We may consider changing this. It would reduce the size of the databse    and obviate the need to create consistency after some type edits. On the    other hand, each time a type is displayed all its supertypes would need to    be consulted. In any case, the inherited field is not needed if only local    roles would end up in this table.</p></blockquote><p><strong>BSO_TYPE_ARGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>a unique ID for the type</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>      <td>name of argument role</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>value of role, the ID of a type</td>    </tr>    <tr>      <td>inherited</td>      <td>BOOL</td>      <td>is role inherited?</td>    </tr>  </table>  <p>PrimaryKey = (typeID,name)</p>  <p>Similar to qualia table. Same comment on the inherited field is relevant    here.</p></blockquote><p><strong>BSO_TYPE_MATCHINGROLES</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>typeID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>role1</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>role2</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>type</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>      </table>  </blockquote><p><strong>BSO_ENTRY</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR,  KEY</td>      <td>a unique ID for the entry, for example e1788</td>    </tr>    <tr>      <td>stem</td>      <td>VARCHAR</td>      <td>name of the entry</td>    </tr>    <tr>      <td>type</td>      <td>VARCHAR, FOREIGN KEY</td>      <td>type of the entry, the ID of a type</td>    </tr>    <tr>      <td>tag</td>      <td>VARCHAR</td>      <td>syntactic category</td>    </tr>    <tr>      <td>cpa</td>      <td>BOOL or NULL</td>      <td>is this a good or bad exemplar for the type?</td>    </tr>    <tr>      <td>comment</td>      <td>VARCHAR</td>      <td>blahblah</td>    </tr>    <tr>      <td>editor</td>      <td>VARCHAR</td>      <td>the editor who last touched this entry</td>    </tr>    <tr>      <td>timestamp</td>      <td>TIMESTAMP</td>      <td>time of last edit</td>    </tr>  </table>  <p>Perhaps we should have a separate table for CPA flags. So we would be able    to collect multiple flags for an entry in case they change over time.</p></blockquote><p><strong>BSO_ENTRY_PREPMAPS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>type1</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>role</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>type2</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table>  <p>type1 and type2 should be renamed in slightly more descriptive names, but    I forgot what those two actually do and we're not touching prepositions yet</p></blockquote><p><strong>BSO_ENTRY_BOUNDARGS</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>localRole</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>remoteRole</td>      <td>ENUMERATION</td>    </tr>    <tr>      <td>remoteType</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>  </table></blockquote><p><strong>BSO_ENTRY_FEATURES</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>entryID</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>name</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>value</td>      <td>VARCHAR</td>    </tr>  </table></blockquote><p><strong>BSO_REFERENCE_INDEX</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td width="52">referred</td>      <td width="183">VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>referent</td>      <td>VARCHAR, FOREIGN KEY</td>    </tr>    <tr>      <td>type</td>      <td>ENUMERATION</td>    </tr>  </table>  <p>ENUMERATION = (type, subtype, qualia, argument, boundarg, prepositionmapping,    matchingrole).</p>  <p>This table is there to give quick acces to all types and entries that    refer to a type. It contains all subtypes, all entires belong to the type    etc, </p></blockquote><p><strong>BSO_CHANGE_LIST</strong></p><blockquote>  <table border="1" cellspacing="0" cellpadding="3">    <tr>      <td>id</td>      <td>VARCHAR, KEY</td>    </tr>    <tr>      <td width="52">date</td>      <td width="183">TIMESTAMP</td>    </tr>    <tr>      <td>editor</td>      <td>VARCHAR</td>    </tr>    <tr>      <td>type</td>      <td>NULL or VARCHAR</td>    </tr>    <tr>      <td>entry</td>      <td>NULL or VARCHAR</td>    </tr>    <tr>      <td>?</td>      <td>&nbsp;</td>    </tr>    <tr>      <td>?</td>      <td>&nbsp;</td>    </tr>  </table>  <p>A list with all changes made to the ontology and lexicon. The smalltalk    version implemented this by adding a revision number to each entry and type.    Changes would not overwrite an existing table row but simply add one. Using    a changelist that can be used to replay changes may be simpler. I don't know    MySQL well enough but I don't think it has the same functionality that Oracle    has, namely one where all changes since the last backup are recorded are    available for recovery.</p></blockquote><h2>3. Other</h2><p>Catherine says there's something fishy with none values, but that it is sufficiently  isolated inside a python wrapper.</p><p>A stable core of python accessors is the interface between databse and GUI.    Some additions may be needed to this core.</p></body></html>